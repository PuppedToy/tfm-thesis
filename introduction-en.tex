Most of the times a project starts as a proof of concept. Typing a few lines in here and there to finally see if it works, see how audience receives it and act on the feedback. This allows a low risk approach to a potential profit. However, this code is usually done in a fast pace with little or no quality at all. We can understand quality code as any code that follows good practices, is maintainable, automatically tested and takes advantage of continuous integration and deployment. To sum it up, is code that is less prone to errors and scales easily.

This proof of concept may succeed and if quality is not taken care of, it may also end in a very expensive code to scale. Quality is not accesory in medium or big sized products, as it allows to keep a good pace with updates with the confidence that it will have almost no bugs and will be easy to debug.

Most of the times, setting up a good environment for quality code means to double or even triple de effort for small product, such as proofs of concept. Thus, it is also common to see these small research projects to be created without good practices nor testing. If the experiment is a failure, nothing happens. However, if the result is a success, it is even more expensive to rebuild the proof of concept into a scalable, testable and automated product.

In this thesis I am going to try to lift the load a bit so setting up a quality code environment is easier for a small project. The aim is to build a framework that can automatically enforce good practices, create a continuous integration workflow and a testing skeleton for a project to help with this tough process and make experiments cheaper without risking the scalability of our successful experiment. To demonstrate that producing quality code is worth the effort even in the tiniest projects, I am going to test this new framework into an example and measure timings and errors, so we can check how expensive is to code well from the beginning.
