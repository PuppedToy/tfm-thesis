Tal y se ha explicado en el capítulo de \nameref{chap:state-of-art}, existen numerosas tecnologías que nos permiten hacer un proyecto de formas distintas. Cada una de ellas tiene sus ventajas e inconvenientes y unas son más populares que otras, pero todas tienen un coste de aprendizaje. En un proyecto de desarrollo web, hace falta dedicar un esfuerzo a generar la infraestructura necesaria para poder utilizar la tecnología. A veces es instalar un paquete, a veces es crear un módulo de código, otras veces es preparar unos procesos en el fichero de definición de proyecto y otras instalar un programa. Entre el tiempo que se dedica a investigar, el tiempo que se dedica a hacer pruebas con la nueva tecnología y el tiempo que se dedica a resolver errores el tiempo de configuración puede resultar ser incluso mayor al tiempo de desarrollo en proyectos pequeños. A esto hay que sumarle que no siempre es trivial resolver interacciones entre distintas tecnologías, como por ejemplo interacciones entre Jenkins y Github o entre Apollo y React.

Es muy fácil olvidar la calidad de código cuando hay una fecha límite para crear el proyecto y se dedica tanto tiempo a jugar con las líneas de código hasta que el resultado es el esperado. Es muy frecuente encontrar marcos de trabajo para una pila concreta de tecnologías que solucionan el problema, pero son todo marcos de trabajo independientes y muchas veces también con filosofías de desarrollo distintas, así que es complicado encontrar dos marcos de trabajo compatibles. En muchas ocasiones no tienen incluidas las pruebas o tienen ligeras variaciones sobre la pila de tecnologías necesarias.

He comentado el concepto calidad de código anteriormente: estamos considerando código de calidad a aquél que siga las buenas prácticas, sea mantenible, se pruebe automáticamente y aproveche la integración y la implementación continuas. A continuación voy a ir desgranando estas condiciones para su mejor comprensión.

Un código que sigue buenas prácticas es aquél que se basa en un estándar corporativo y, por tanto, todos sus desarrolladores escriben código que tiene forma similar. Generalmente, el estándar corporativo se alinea con un estándar que ha ido generando la comunidad de desarrolladores del lenguaje en cuestión a base de experiencia. Quizá un lenguaje particular dispone de una herramienta que, al utilizarla, la experiencia dicta que genera más problemas que soluciones, así que es preferible evitar su uso. En otras ocasiones, las buenas prácticas establecen los criterios de nombrado de variables, el tipo de indentación, la información que se espera ver en los comentarios y qué comentarios se esperan ver en cada módulo. Las buenas prácticas tienen el mismo objetivo que las pruebas automáticas: evitar errores. No todas las buenas prácticas son evaluables por procesos automáticos, pero la mayoría sí lo son. Y esos procesos automáticos requieren una configuración. Sería cómodo poder evitarse este tiempo si se asume que todos los proyectos van a escribirse a los estándares de la comunidad de desarrolladores de Javascript y se utilizan todos los procesos automáticos validados por la comunidad para forzar la aplicación de estas buenas prácticas.

Un código mantenible es aquél que, a medida que escala en tamaño, sigue siendo fácil conocer la función de cada parte y se puede mantener independiente cada módulo. Es muy difícil librarse de todas las dependencias entre modulos, pero al fin y al cabo el código es mantenible mientras sea fácil identificar qué hace cada módulo de forma independiente. Es importante mantener un orden en el directorio de ficheros y un sistema de nombrado apropiado. Es por eso que la estructura del proyecto debe estar pensada de antemano en base de las tecnologías que se vayan a utilizar y, asimismo, la estrcutura debe estar preparada para recibir ampliaciones. Todo este esfuerzo de planificación no tiene por qué hacerse en cada nuevo proyecto, dado que es muy probable que una estructura particular encaje en todos los proyectos que compartan un conjunto dado de tecnologías. Es por eso que en la comunidad de desarrolladores se han ido generando estructuras para los conjuntos de tecnologías más habituales que están validadas por al experiencia. Sería bueno poder evitarse ese proceso de diseño sabiendo que ese conocimiento existe en la comunidad.

Además, el código es mantenible si modificar un módulo no tiene riesgo de generar un error en un módulo distinto. Para esto, se ha creado el apartado específico de las pruebas automáticas. Todo código que se cree debe estar soportado por una batería de pruebas que se encargarán de generar una alerta cuando el código deje de hacer lo que debería. Esas pruebas hay que escribirlas y suponen un esfuerzo inevitable. No existe proceso automático que entienda las necesidades de negocio de un proyecto y las traduzca a pruebas automáticas, pero sí que existen algunas pruebas automáticas independientes de las necesidades de negocio como el análisis de imágenes instantáneas del producto. Este tipo de pruebas avisan en caso de que el producto cambie de forma, y es responsabilidad del desarollador analizar si ese cambio en la instantánea era esperado o no. Con todo y con eso, las pruebas automáticas requieren configuración y estructura y dependen de las tecnologías implicadas. Así que un proceso automático sí podría encargarse de, dadas unas tecnologías, generar dichas estructura y configuración necesarias para poder escribir casos de prueba. Todo esto se ha comentado y explicado más en detalle en el apartado de \nameref{section:unit-testing}.

Por último, la integración contínua. Muchas veces queremos tener el producto en un lugar accesible, queremos protegerlo de versiones defectuosas, queremos tener una versión del producto de desarrollo para poder actuar sin miedo sobre ella y una versión en producción que sea la que está abierta al público. Nos gusta estar tranquilos y saber que nuestro código en producción no contiene características a medias, defectos conocidos ni comportamientos inesperados. Un proceso automático puede encargarse de integrar todo lo que se ha planteado anteriormente: desplegar automáticamente el código a producción cuidando de todos nuestros miedos. Ese proceso automático puede realizar los casos de pruebas que hemos descrito en el párrafo anterior y, en caso de resultar defectuoso, impedir el despliegue. Y ese proceso automático se suele generar configurando herramientas específicas. Si conocemos el conjunto de tecnologías que intervienen, de nuevo no tendríamos por qué dedicar esfuerzo a escribir toda la configuración necesaria para que el despliegue se ejecute como queremos. Todo esto se ha comentado y explicado más en detalle en el apartado de \nameref{section:ci-cd-flow}.

Es por todo esto por lo que se ha planteado el marco de trabajo que se quiere crear: un marco de trabajo que ya ha pensado toda la configuración para un número de combinaciones de tecnologías y teniendo siempre la misma filosofía en mente: priorizar la calidad de código y el mínimo esfuerzo en configuración, manteniendo en la medida de lo posible flexibilidad, estando totalmente documentado y guardando todos los procesos automáticos en un lugar accesible. Si existe un marco de trabajo suficientemente extenso y fácil de usar que proporciona infraestructura para código de calidad, se puede convertir en la herramienta de facto para cualquier desarrollador web y, mientras su pila de tecnologías sea una de las que ofrece el marco, va a poderse evitar todo este esfuerzo de configuración mencionado anteriormente para poder concentrarse en lo que de verdad importa: que su código haga lo que se supone que tiene que hacer y pueda crecer manteniendo esa máxima.
