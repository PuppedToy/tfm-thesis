Para el desarollo de la integración continua y el despliegue continuo se han utilizado dos herramientas libres: Jenklins y CircleCI. El objetivo era minimizar el esfuerzo de configuración, pero esta tarea se dificulta sabiendo que, tal y como explica el diagrama de la figura \cref{fig:architecture}, puede haber un total de 4 máquinas interviniendo en el despliegue. Una de las cuales es el servidor de git y se asume que se está utilizando Github, así que se descarta. La máquina que se encarga del desarollo continuo es necesaria solo si se utiliza Jenkins o si se utiliza el plan de pago de CircleCI. Como se ha ido comentando a lo largo del trabajo, se descarta cualquier opción de pago, así que se va a asumir que si se utiliza Jenkins, se dispone de una máquina para el servidor de integración continua y si se utiliza CircleCI no.

Tanto jenkins como CircleCI disponen de la posibilidad de configurar el proyecto mediante un fichero de configuración que se incluye dentro del repositorio. Esto implica que el usuario no tendrá que preocuparse por casi nada de la configuración del proyecto. En el caso de Jenkins, este fichero se llama Jenkinsfile y utiliza la sintaxis Groovy y en el caso de CircleCI, este fichero se llama .circleci/config.yml y utiliza la sintaxis YAML. Sin embargo, ambas herramientas carecen de un método para generar automáticamente el proyecto, así que se requiere un mínimo trabajo manual para generar el proyecto y conectarlo al repositorio. En el caso de Jenkins, además, es necesario el plugin de Github y el plugin SSH Publisher para poder realizar una integración completa. Jenkins es ligeramente más complicado de montar porque requiere tener una máquina disponible para hacer de servidor. Sin embargo, su instalación es directa y se ejecuta únicamente mediante el mandato jenkins --daemon.

Respecto a la máquina que va a alojar el código, se espera que posea por lo menos los siguientes paquetes:
\begin{enumerate}
  \item git
  \item node y npm
  \item pm2: esta herramienta permite automatizar el despliegue en un solo fichero de configuración. El marco de trabajo asume que se utiliza pm2 para poder desplegar el código mediante un solo mandato.
  \item ssh: es necesario para poder comunicarse con la máquina.
  \item Visibilidad en la red: esto no es un paquete como tal, pero es un requisito indispensable. En el caso de Jenkins, la máquina objetivo debe estar dentro de la misma red (o ser la misma máquina) que la máquina que aloja Jenkins. En el caso de CircleCI, es imprescindible que la máquina tenga una dirección IP estática o tenga asociado un nombre de dominio a una IP Dinámica mediante \gls{ddns}. Además, deberá tener abiertos el puerto 80 y el 8080.
\end{enumerate}
Tal y como se comenta en \nameref{chap:further-steps}, se pretende dar soporte a Docker. Una vez se logre este hito, será indispensable que la máquina de la aplicación tenga instalado Docker. Para estos requisitos mínimos se ha elaborado un fichero de instalación que habrá que ejecutar una sola vez en la máquina que vaya a alojar el código, asumiendo que la máquina destino tiene acceso a apt. En caso de tener una distribución con otro servidor de paquetes, el usuario deberá buscar por su cuenta la forma de instalar los paquetes mencionados anteriormente. Dada una máquina con las características mencionadas, el fichero generado tanto para Jenkins como para CircleCI será capaz por sí mismo de ordenar a la herramienta en cuestión el despliegue automático en el servidor que vaya a alojar la aplicación.

Para simplificar el despliegue, se asume que la máquina que vaya a alojar la aplicación va a hacerlo utilizando el puerto 80 (o 443 en el caso de HTTPS) y que, la misma máquina va a utilizar el puerto 8080 para alojar la misma aplicación en preproducción. Además, se asume que la rama develop del servidor de git se conectará al servidor de preproducción y que la rama master se conectará al servidor de producción. Todo esto ya está contemplado en los ficheros de configuración tanto de Jenkins como de CircleCI.

Quiero aclarar que soy consciente de que esta es sin duda la parte más engorrosa del proyecto. Por su propia naturaleza, la variabilidad del entorno, la intervención de la red y el uso de herramientas muy gráficas como Jenkins y CircleCI, la cantidad de trabajo manual necesaria para poner en marcha el proyecto es mucho mayor de la que desearía. A lo largo del proyecto me he ido dando cuenta de la gran necesidad que hay de automatizar aun más todo este proceso y, por tanto, me he dado cuenta de que Docker debería haber sido parte del proyecto desde el principio. Sin embargo, mis recursos me han impedido añadirlo en esta primera fase y, por tanto, lo he dejado como máxima prioridad en el apartado de \nameref{chap:further-steps}. Docker no permitirá toda la automatización del sistema, pero sí permitirá una mejor integración con las herramientas mencionadas en este capítulo y reducirán mucho la carga de instalación de paquetes en la máquina que aloja la aplicación.
